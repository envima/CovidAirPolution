---
title: "COVID pm 2.5 playground"
always_allow_html: true
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Set up working environment and defaults --------------------------------------
library(envimaR)
if(Sys.info()[["nodename"]] == "PC19616"){
  source("~/plygrnd/CovidAirPolution/CovidAirPolution/src/functions/000_setup.R")
} else {
  source("~/project/cov/CovidAirPolution/src/functions/000_setup.R")  
}
# Load Italy -------------------------------------------------------------------
# italy = compileDataIT()
# saveRDS(italy, file.path(envrmt$path_tmp, "italy.RDS"))
# italy = readRDS(file.path(envrmt$path_tmp, "italy.RDS"))
# nuts3_mean = italy$it_nuts3_mean

# Load Germany -----------------------------------------------------------------
# germany = compileDataDE()
# saveRDS(germany, file.path(envrmt$path_tmp, "germany.RDS"))
germany = readRDS(file.path(envrmt$path_tmp, "germany.RDS"))
nuts3_mean = germany$de_nuts3_mean
```


## Übersicht über die verfügbaren Daten zur zeitlichen Entwicklung in Deutschland

Die Abbildung zeigt die räumliche Verteilung der PM 2.5 Messungen.
```{r, eval = TRUE, echo=FALSE, warning=FALSE, message=FALSE}
# mapview(italy$pm_waqi_points$pts, popup = italy$pm_waqi_points$pop, 
#         legend = FALSE, ncol="pm25max")

mapview(germany$pm_uba_points$pts, popup = germany$pm_uba_points$pop, 
        legend = FALSE, ncol="pm25max")
```


## Exemplarische Auswertung für die einzelnen Regionen

Übersicht über die Verteilung von mittlerer bwz. maximaler PM 2.5 Konzentration und dem Median der täglichen COVID-19 Neuinfektionen bzw. der Summe an Covid-19 Infektionen in NUTS3-Regionen Deutschlands.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
overview = lapply(seq(length(nuts3_mean)), function(r){
  data.frame(nuts3 = names(nuts3_mean[r]),
             pm25_mean =  c(mean(nuts3_mean[[r]]$pm25_mean), mean(nuts3_mean[[r]]$pm25_mean),
                            max(nuts3_mean[[r]]$pm25_mean), max(nuts3_mean[[r]]$pm25_mean)),
             covid_cases  = c(median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases),
                              median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases)),
             var = c("mean PM2.5 x median covid", "mean PM2.5 x sum covid", "max PM2.5 x median covid", "max PM2.5 x sum covid"))
})
overview = do.call(rbind, overview)

ggplot(data =overview, aes(x = pm25_mean, y = covid_cases)) + 
  geom_point() +
  geom_smooth() +
  scale_y_continuous(trans='log2') + 
  labs(title = "Overivew PM2.5 x Covid-19 cases", x = "PM 2.5", y = "Covid-19 cases (log)") +
  facet_wrap(~var, ncol =2, nrow = 2, scales = "free_x")
```

Clusteranalyse über mittlere PM2.5 und den Median der täglichen Covid-Infektionen. Es werden nur Standorte mit einem Median der Infektionen größer oder gleich 2 berücksichtigt. Daten wurden vorher auf jeweils maximalen Wert normiert.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
dat = overview[overview$var == "mean PM2.5 x median covid", c("nuts3", "pm25_mean", "covid_cases")]
dat = dat[dat$covid_cases >= 2,]

dat$pm25_mean = dat$pm25_mean/max(dat$pm25_mean)
dat$covid_cases = dat$covid_cases/max(dat$covid_cases)
cls = kmeans(x = dat[, -1], centers = 4)
dat$cluster = as.character(cls$cluster)

ggplot(data = dat, aes(x = pm25_mean, y = covid_cases, colour = cluster)) +
  geom_point() +
  labs(title = "Clusteranalyse PM2.5 x Median der täglichen Covid-19 Infektionen", x = "PM 2.5", y = "Covid-19 cases (norm)", colour = "Cluster-ID")
```


```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
test = nuts3_mean$`SK Köln`
test = nuts3_mean$`SK Krefeld`
test = nuts3_mean$`SK Mönchengladbach`
head(test)

ccf(test$new_cases, test$pm25_mean)


test = nuts3_mean$`SK München`
ccf(test$new_cases, test$pm25_mean)


test = nuts3_mean$`LK Gießen`
ccf(test$new_cases, test$pm25_mean)


model2 <- glm(new_cases ~ pm25_mean, data = test, family = quasipoisson)
model2 <- gam(new_cases ~ pm25_mean, data = test, family = quasipoisson)
summary(model2)

```



## Zeitreihen gruppiert nach Cluster-ID

Die Zahl vor "station average PM2.5" im jeweils ersten Plot eines Orts gibt die Anzahl der PM-Stationen an, deren Zeitreihe für die Analyse gemittelt wurden, um das Messignal zu stabilisieren.

Die Sortierung erfolgt nach Cluster-ID und mittlerem PM2.5 Wert.

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
#Die folgenden Abbildungen zeigen jeweils (i) die Zeitreihen PM 2.5 und neuen COVID-Fälle, (ii) die wavelet coherence, (iii) die Phasendifferenz zwischen den periodischen Komponenten (grün = Differenz nahe 0, Gelb-Grün = PM 2.5 früher als COVID, Türkis = Covid früher als PM 2.5, Blau = inverse Zusammenhang, PM 2.5 vor COVID, Rot = inverser Zusammenhang, Covid vor PM 2.5) und (iv) die Übersicht über wichtige Phasen.


dat = dat[order(dat$cluster, dat$pm25_mean ), ]

coherence = list()
angl = list()

for(c in seq(nrow(dat))){
  
  # Plot of PM 2.5 and COVID time series
  # fig = plot_ly()
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~pm25_mean,
  #             name = paste("PM 2.5", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "red"), marker = list(color = "red"))
  # 
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~new_cases,
  #             yaxis = "y2", name = paste("New cases", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "blue"), marker = list(color = "blue"))
  # 
  # fig = fig %>% layout(title= names(it_nuts3_mean[l]),
  #                      yaxis = list(title = "PM 2.5 mean"),
  #                      yaxis2 = list(overlaying = "y", side = "right", title = "new cases"))
  # print(fig)
  print("<P style='page-break-before: always'>")
  
  l = dat[c, "nuts3"]
  
  g = ggplot() +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = pm25_mean, colour  = "PM 2.5 mean")) +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = new_cases/5, colour  = "New cases")) +
    scale_y_continuous(sec.axis = sec_axis(~.*5, name = "New cases")) +
    labs(title = paste(names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"], " | ", substr(nuts3_mean[[l]]$stationname[1], 1, 1), "station average PM2.5 = ", round(mean(nuts3_mean[[l]]$pm25_mean), 2)), x = "Date", y = "PM 25 mean") +
    scale_x_date(date_labels="%d.%m", date_breaks  ="2 day") + 
    theme(axis.text.x = element_text(angle=45)) + 
    scale_colour_manual(name = NULL, values = c("blue", "red"))
  
  print(g)

  # Plot of PM 2.5 and COVID wavelet analysis
  wc = analyze.coherency(as.data.frame(nuts3_mean[[l]][, c("date", "pm25_mean", "new_cases")])[, -4],
                         my.pair = c("pm25_mean", "new_cases"),
                         loess.span = 0,
                         dt = 1, dj = 1/20,
                         window.type.t = "bar", window.type.s = "bar",
                         window.size.t = 5, window.size.s = 1/4,
                         make.pval = TRUE, method = "white.noise",
                         n.sim = 100,
                         verbose = FALSE)
  
  
  # wc.image(wc, which.image = "wp",
  #        n.levels = 250,
  #        color.key = "interval",
  #        siglvl.contour = 0.1, siglvl.arrow = 0.1,
  #        legend.params = list(lab = "cross-wavelet power levels"),
  #        show.date = TRUE, main = paste("Cross-wavelet power", names(it_nuts3_mean[l])))
  #
  # wc.avg(wc, which.avg = "wp", exponent = 1,
  #        main = paste("Main frequencies of cross-wavelet power", names(it_nuts3_mean[l])))
  
  wc.image(wc, which.image = "wc",
           n.levels = 250, color.key = "interval",
           siglvl.contour = 0.1, siglvl.arrow = 0.1,
           legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
           main = paste("Wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  # wc.phasediff.image(wc, which.contour = "wc",
  #                    show.date = TRUE,
  #                    main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc.avg(wc, which.avg = "wc", exponent = 1, periodlab = "period (days)",
         main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  
  
  # wc.sel.phases(wc, sel.period = 4, siglvl = 1, show.date = TRUE)
  
  sel.period = 3.6
  sel.rnum = which(abs(wc$Period - sel.period) == min(abs(wc$Period - sel.period)))
  
  
  # plot(wc$Phase.x[sel.rnum, ], type = "l", col = "red")
  # + lines(wc$Phase.y[sel.rnum, ], col = "blue")
  # + lines(wc$Angle[sel.rnum, ], col = "green")

  angl[c] = list(data.frame(phasex = wc$Phase.x[sel.rnum, ],
                            phasey = wc$Phase.y[sel.rnum, ],
                            angle = wc$Angle[sel.rnum, ], 
                            date = wc$series$date,
                            cluster_id = dat[c, "cluster"]))
  names(angl)[c] = names(nuts3_mean[l])
  
  coherence[c] = list(data.frame(coherence_avg = wc$Coherence.avg, 
                            coherence_avg_pval = wc$Coherence.avg.pval, 
                            period = wc$Period,
                            cluster_id = dat[c, "cluster"]))
  names(coherence)[c] = names(nuts3_mean[l])
  

}


ang = angl
ang = do.call("rbind", ang)
a1 = aggregate(ang$angle, list(ang$date, ang$cluster_id), FUN = mean)
names(a1) = c("date", "cluster_id", "angle")


ggplot(data = ang[which(substr(rownames(ang), 1, 6) == "SK Kre"), ], aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()
ggplot(data = a1, aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()
ggplot(data = a1, aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()



dtwclust 


dtw_cluster = tsclust(normalized_price, type="partitional",k=5,
                      distance="dtw_basic",centroid = "pam",seed=1234,trace=T,
                      args = tsclust_args(dist = list(window.size = 5)))


coh = coherence
coh[[which(names(coh) == "SK Halle")]] = NULL
coh[[which(names(coh) == "SK Braunschweig")]] = NULL

test = do.call("rbind", coh)

test




t1 = lapply(unique(test$wc.Period), function(u){
  data.frame(cavg = mean(test[test$wc.Period == u, "wc.Coherence.avg"]),
             per = u)
})
t1 = do.call("rbind", t1)

t = aggregate(. ~ period, data = test, FUN = mean)
t1 = aggregate(test$coherence_avg, list(test$period, test$cluster_id), FUN = mean)
names(t1) = c("period", "cluster_id", "coherence_avg")

ggplot(data = t, aes(x = coherence_avg, y = period)) + geom_line()

ggplot(data = t1, aes(x = coherence_avg, y = period, color = cluster_id, group = cluster_id)) + geom_path()

plot(t1$coherence_avg, t1$period, type = "l" )




# https://rpubs.com/ibn_abdullah/rwcoher
# https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-019-7607-2
# http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf
# https://ehjournal.biomedcentral.com/articles/10.1186/1476-069X-13-102

```

Daten kleiner 2

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
dat = overview[overview$var == "mean PM2.5 x median covid", c("nuts3", "pm25_mean", "covid_cases")]
dat = dat[dat$covid_cases < 2,]

dat$pm25_mean = dat$pm25_mean/max(dat$pm25_mean)
dat$covid_cases = dat$covid_cases/max(dat$covid_cases)
cls = kmeans(x = dat[, -1], centers = 4)
dat$cluster = as.character(cls$cluster)

ggplot(data = dat, aes(x = pm25_mean, y = covid_cases, colour = cluster)) +
  geom_point() +
  labs(title = "Clusteranalyse PM2.5 x Median der täglichen Covid-19 Infektionen", x = "PM 2.5", y = "Covid-19 cases (norm)", colour = "Cluster-ID")
```


```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
#Die folgenden Abbildungen zeigen jeweils (i) die Zeitreihen PM 2.5 und neuen COVID-Fälle, (ii) die wavelet coherence, (iii) die Phasendifferenz zwischen den periodischen Komponenten (grün = Differenz nahe 0, Gelb-Grün = PM 2.5 früher als COVID, Türkis = Covid früher als PM 2.5, Blau = inverse Zusammenhang, PM 2.5 vor COVID, Rot = inverser Zusammenhang, Covid vor PM 2.5) und (iv) die Übersicht über wichtige Phasen.


dat = dat[order(dat$cluster, dat$pm25_mean ), ]

for(c in seq(nrow(dat))){
  
  # Plot of PM 2.5 and COVID time series
  # fig = plot_ly()
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~pm25_mean,
  #             name = paste("PM 2.5", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "red"), marker = list(color = "red"))
  # 
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~new_cases,
  #             yaxis = "y2", name = paste("New cases", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "blue"), marker = list(color = "blue"))
  # 
  # fig = fig %>% layout(title= names(it_nuts3_mean[l]),
  #                      yaxis = list(title = "PM 2.5 mean"),
  #                      yaxis2 = list(overlaying = "y", side = "right", title = "new cases"))
  # print(fig)
  print("<P style='page-break-before: always'>")
  l = dat[c, "nuts3"]
  
  g = ggplot() +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = pm25_mean, colour  = "PM 2.5 mean")) +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = new_cases/5, colour  = "New cases")) +
    scale_y_continuous(sec.axis = sec_axis(~.*5, name = "New cases")) +
    labs(title = paste(names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"], " | ", substr(nuts3_mean[[l]]$stationname[1], 1, 1), "station average PM2.5 = ", round(mean(nuts3_mean[[l]]$pm25_mean), 2)), x = "Date", y = "PM 25 mean") +
    scale_x_date(date_labels="%d.%m", date_breaks  ="2 day") + 
    theme(axis.text.x = element_text(angle=45)) + 
    scale_colour_manual(name = NULL, values = c("blue", "red"))
  
  print(g)

  # Plot of PM 2.5 and COVID wavelet analysis
  wc = analyze.coherency(as.data.frame(nuts3_mean[[l]][, c("date", "pm25_mean", "new_cases")])[, -4],
                         my.pair = c("pm25_mean", "new_cases"),
                         loess.span = 0,
                         dt = 1, dj = 1/20,
                         window.type.t = "bar", window.type.s = "bar",
                         window.size.t = 5, window.size.s = 1/4,
                         make.pval = TRUE, method = "white.noise",
                         n.sim = 100,
                         verbose = FALSE)
  
  
  # wc.image(wc, which.image = "wp",
  #        n.levels = 250,
  #        color.key = "interval",
  #        siglvl.contour = 0.1, siglvl.arrow = 0.1,
  #        legend.params = list(lab = "cross-wavelet power levels"),
  #        show.date = TRUE, main = paste("Cross-wavelet power", names(it_nuts3_mean[l])))
  #
  # wc.avg(wc, which.avg = "wp", exponent = 1,
  #        main = paste("Main frequencies of cross-wavelet power", names(it_nuts3_mean[l])))
  
  wc.image(wc, which.image = "wc",
           n.levels = 250, color.key = "interval",
           siglvl.contour = 0.1, siglvl.arrow = 0.1,
           legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
           main = paste("Wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  # wc.phasediff.image(wc, which.contour = "wc",
  #                    show.date = TRUE,
  #                    main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc.avg(wc, which.avg = "wc", exponent = 1, periodlab = "period (days)",
         main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
}

# https://rpubs.com/ibn_abdullah/rwcoher
# https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-019-7607-2
# http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf
# https://ehjournal.biomedcentral.com/articles/10.1186/1476-069X-13-102

```



