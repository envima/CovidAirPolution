---
title: "COVID pm 2.5 playground"
output:
  html_document:
    df_print: paged
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Set up working environment and defaults --------------------------------------
library(envimaR)
if(Sys.info()[["nodename"]] == "PC19616"){
  source("~/plygrnd/CovidAirPolution/CovidAirPolution/src/functions/000_setup.R")
} else {
  source("~/project/CovidAirPolution/src/functions/000_setup.R")  
}
# Load Italy -------------------------------------------------------------------
# italy = compileDataIT()
# saveRDS(italy, file.path(envrmt$path_tmp, "italy.RDS"))
# italy = readRDS(file.path(envrmt$path_tmp, "italy.RDS"))
# nuts3_mean = italy$it_nuts3_mean

# Load Germany -----------------------------------------------------------------
# germany = compileDataDE()
# saveRDS(germany, file.path(envrmt$path_tmp, "germany.RDS"))
germany = readRDS(file.path(envrmt$path_tmp, "germany.RDS"))
nuts3_mean = germany$de_nuts3_mean
```


## Übersicht über die verfügbaren Daten zur zeitlichen Entwicklung in Deutschland

Die Abbildung zeigt die räumliche Verteilung der PM 2.5 Messungen.
```{r, eval = TRUE, echo=FALSE, warning=FALSE, message=FALSE}
# mapview(italy$pm_waqi_points$pts, popup = italy$pm_waqi_points$pop, 
#         legend = FALSE, ncol="pm25max")

mapview(germany$pm_uba_points$pts, popup = germany$pm_uba_points$pop, 
        legend = FALSE, ncol="pm25max")
```


## Exemplarische Auswertung für die einzelnen Regionen

Übersicht über die Verteilung von mittlerer bwz. maximaler PM 2.5 Konzentration und dem Median der täglichen COVID-19 Neuinfektionen bzw. der Summe an Covid-19 Infektionen in NUTS3-Regionen Deutschlands.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
overview = lapply(seq(length(nuts3_mean)), function(r){
  data.frame(nuts3 = names(nuts3_mean[r]),
             pm25_mean =  c(mean(nuts3_mean[[r]]$pm25_mean), mean(nuts3_mean[[r]]$pm25_mean),
                            max(nuts3_mean[[r]]$pm25_mean), max(nuts3_mean[[r]]$pm25_mean)),
             covid_cases  = c(median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases),
                              median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases)),
             var = c("mean PM2.5 x median covid", "mean PM2.5 x sum covid", "max PM2.5 x median covid", "max PM2.5 x sum covid"))
})
overview = do.call(rbind, overview)

ggplot(data =overview, aes(x = pm25_mean, y = covid_cases)) + 
  geom_point() +
  geom_smooth() +
  scale_y_continuous(trans='log2') + 
  labs(title = "Overivew PM2.5 x Covid-19 cases", x = "PM 2.5", y = "Covid-19 cases (log)") +
  facet_wrap(~var, ncol =2, nrow = 2, scales = "free_x")
```

Clusteranalyse über mittlere PM2.5 und den Median der täglichen Covid-Infektionen. Es werden nur Standorte mit einem Median der Infektionen größer oder gleich 2 berücksichtigt. Daten wurden vorher auf jeweils maximalen Wert normiert.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
dat = overview[overview$var == "mean PM2.5 x median covid", c("nuts3", "pm25_mean", "covid_cases")]
dat = dat[dat$covid_cases >= 2,]

dat$pm25_mean = dat$pm25_mean/max(dat$pm25_mean)
dat$covid_cases = dat$covid_cases/max(dat$covid_cases)
cls = kmeans(x = dat[, -1], centers = 4)
dat$cluster = as.character(cls$cluster)

ggplot(data = dat, aes(x = pm25_mean, y = covid_cases, colour = cluster)) +
  geom_point() +
  labs(title = "Clusteranalyse PM2.5 x Median der täglichen Covid-19 Infektionen", x = "PM 2.5", y = "Covid-19 cases (norm)", colour = "Cluster-ID")
```

## Zeitreihen gruppiert nach Cluster-ID

Die Zahl vor "station average PM2.5" im jeweils ersten Plot eines Orts gibt die Anzahl der PM-Stationen an, deren Zeitreihe für die Analyse gemittelt wurden, um das Messignal zu stabilisieren.

Die Sortierung erfolgt nach Cluster-ID und mittlerem PM2.5 Wert.

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
#Die folgenden Abbildungen zeigen jeweils (i) die Zeitreihen PM 2.5 und neuen COVID-Fälle, (ii) die wavelet coherence, (iii) die Phasendifferenz zwischen den periodischen Komponenten (grün = Differenz nahe 0, Gelb-Grün = PM 2.5 früher als COVID, Türkis = Covid früher als PM 2.5, Blau = inverse Zusammenhang, PM 2.5 vor COVID, Rot = inverser Zusammenhang, Covid vor PM 2.5) und (iv) die Übersicht über wichtige Phasen.


dat = dat[order(dat$cluster, dat$pm25_mean ), ]

for(c in seq(nrow(dat))){
  
  # Plot of PM 2.5 and COVID time series
  # fig = plot_ly()
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~pm25_mean,
  #             name = paste("PM 2.5", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "red"), marker = list(color = "red"))
  # 
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~new_cases,
  #             yaxis = "y2", name = paste("New cases", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "blue"), marker = list(color = "blue"))
  # 
  # fig = fig %>% layout(title= names(it_nuts3_mean[l]),
  #                      yaxis = list(title = "PM 2.5 mean"),
  #                      yaxis2 = list(overlaying = "y", side = "right", title = "new cases"))
  # print(fig)
  
  l = dat[c, "nuts3"]
  
  g = ggplot() +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = pm25_mean, colour  = "PM 2.5 mean")) +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = new_cases/5, colour  = "New cases")) +
    scale_y_continuous(sec.axis = sec_axis(~.*5, name = "New cases")) +
    labs(title = paste(names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"], " | ", substr(nuts3_mean[[l]]$stationname[1], 1, 1), "station average PM2.5 = ", round(mean(nuts3_mean[[l]]$pm25_mean), 2)), x = "Date", y = "PM 25 mean") +
    scale_x_date(date_labels="%d.%m", date_breaks  ="2 day") + 
    theme(axis.text.x = element_text(angle=45)) + 
    scale_colour_manual(name = NULL, values = c("blue", "red"))
  
  print(g)

  # Plot of PM 2.5 and COVID wavelet analysis
  wc = analyze.coherency(as.data.frame(nuts3_mean[[l]][, c("date", "pm25_mean", "new_cases")])[, -4],
                         my.pair = c("pm25_mean", "new_cases"),
                         loess.span = 0,
                         dt = 1, dj = 1/20,
                         window.type.t = "bar", window.type.s = "bar",
                         window.size.t = 5, window.size.s = 1/4,
                         make.pval = TRUE, method = "white.noise",
                         n.sim = 100,
                         verbose = FALSE)
  
  
  # wc.image(wc, which.image = "wp",
  #        n.levels = 250,
  #        color.key = "interval",
  #        siglvl.contour = 0.1, siglvl.arrow = 0.1,
  #        legend.params = list(lab = "cross-wavelet power levels"),
  #        show.date = TRUE, main = paste("Cross-wavelet power", names(it_nuts3_mean[l])))
  #
  # wc.avg(wc, which.avg = "wp", exponent = 1,
  #        main = paste("Main frequencies of cross-wavelet power", names(it_nuts3_mean[l])))
  
  wc.image(wc, which.image = "wc",
           n.levels = 250, color.key = "interval",
           siglvl.contour = 0.1, siglvl.arrow = 0.1,
           legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
           main = paste("Wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  # wc.phasediff.image(wc, which.contour = "wc",
  #                    show.date = TRUE,
  #                    main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc.avg(wc, which.avg = "wc", exponent = 1, periodlab = "period (days)",
         main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
}

# https://rpubs.com/ibn_abdullah/rwcoher
# https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-019-7607-2
# http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf
# https://ehjournal.biomedcentral.com/articles/10.1186/1476-069X-13-102

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

```