---
title: "COVID pm 2.5 playground"
always_allow_html: true
editor_options:
  chunk_output_type: console
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Set up working environment and defaults --------------------------------------
library(envimaR)
if(Sys.info()[["nodename"]] == "PC19616"){
  source("~/plygrnd/CovidAirPolution/CovidAirPolution/src/functions/000_setup.R")
} else {
  source("~/project/cov/CovidAirPolution/src/functions/000_setup.R")  
}
# Load Italy -------------------------------------------------------------------
# italy = compileDataIT()
# saveRDS(italy, file.path(envrmt$path_tmp, "italy.RDS"))
# italy = readRDS(file.path(envrmt$path_tmp, "italy.RDS"))
# nuts3_mean = italy$it_nuts3_mean

# Load Germany -----------------------------------------------------------------
# germany = compileDataDE()
# saveRDS(germany, file.path(envrmt$path_tmp, "germany.RDS"))
germany = readRDS(file.path(envrmt$path_tmp, "germany.RDS"))
nuts3_mean = germany$de_nuts3_mean
```


## Geographical overview of available PM2.5 station observations

```{r, eval = TRUE, echo=FALSE, warning=FALSE, message=FALSE}
# mapview(italy$pm_waqi_points$pts, popup = italy$pm_waqi_points$pop, 
#         legend = FALSE, ncol="pm25max")
mapview(germany$pm_uba_points$pts, popup = germany$pm_uba_points$pop, 
        legend = FALSE, ncol="pm25max")
```


## Data and Methods
Data on PM2.5 has been provided by the German environmental protection agency (UBN). Data on daily COVID-19 cases and death has been provided by the Robert-Koch-Institut.

## Mean development of PM2.5 and COVID-19 cases in Germany

The following figure shows the country wide average of daily PM2.5 and new, smoothed COVID-19 cases.


14.03. Kontaktbeschränkung, 17.03. Einrichtungsschließung
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
nuts3_mean_avg = lapply(nuts3_mean, "[", c("date", "date_day", "pm25_mean", "new_cases", "new_cases_smooth", "cases_smooth", "deaths_smooth", "new_deaths", "new_deaths_smooth"))
nuts3_mean_avg = do.call("rbind", nuts3_mean_avg)
nuts3_mean_avg = as.data.frame(nuts3_mean_avg)[, -ncol(nuts3_mean_avg)]
nuts3_mean_avg = nuts3_mean_avg[nuts3_mean_avg$date >= as.POSIXct("2020-02-15", tz = "CET"), ]

nuts3_mean_avg = aggregate(. ~ date, data = nuts3_mean_avg, FUN = mean)
nuts3_mean_avg$date_day = paste(nuts3_mean_avg$date, substr(weekdays(nuts3_mean_avg$date), 1, 1))

ggplot() + 
  geom_line(data = nuts3_mean_avg, aes(x = date, y = pm25_mean, color = "PM2.5")) + 
  geom_line(data = nuts3_mean_avg, aes(x = date, y = new_cases_smooth, color = "New cases (smoothed)")) + 
  labs(title = "PM2.5 x daily new Covid-19 cases (smoothed)", x = "Date", y = "Value") +
  scale_x_datetime(date_labels = "%d.%m - %a", date_breaks = "1 day") + 
  scale_color_manual(values=c("#CC6666", "#9999CC")) +
  theme(axis.text.x = element_text(angle=90))
```


The following figure shows the country wide average of daily PM2.5 and new, smoothed COVID-19 cases.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
# nuts3_mean_avg_org = nuts3_mean_avg
nuts3_mean_avg = nuts3_mean_avg_org

nuts3_mean_avg = nuts3_mean_avg[nuts3_mean_avg$date >= as.POSIXct("2020-02-15 CET") & nuts3_mean_avg$date <= as.POSIXct("2020-04-01 CEST"), ]

new_cases_smooth_detr = glm(new_cases_smooth ~ date,  family = poisson, data =nuts3_mean_avg)
new_cases_smooth_detr = residuals(new_cases_smooth_detr)
nuts3_mean_avg$new_cases_smooth_detr = new_cases_smooth_detr

ggplot() + 
  geom_line(data = nuts3_mean_avg, aes(x = date, y = pm25_mean, color = "PM2.5")) + 
  geom_line(data = nuts3_mean_avg, aes(x = date, y = new_cases_smooth_detr, color = "New cases (smoothed, detrended)")) +
  geom_line(data = nuts3_mean_avg, aes(x = date, y = new_cases_smooth, color = "New cases (smoothed)")) + 
  labs(title = "PM2.5 x daily new Covid-19 cases (smoothed)", x = "Date", y = "Value") +
  scale_x_datetime(date_labels = "%d.%m - %a", date_breaks = "1 day") + 
  scale_color_manual(values=c("#CC6666", "#9999CC", "#9988CC")) +
  theme(axis.text.x = element_text(angle=90))

ccf(nuts3_mean_avg$new_cases_smooth_detr, nuts3_mean_avg$pm25_mean)

wc = analyze.coherency(nuts3_mean_avg,
                       my.pair = c("pm25_mean", "new_cases_smooth_detr"),
                       loess.span = 0,
                       dt = 1, dj = 1/12,
                       window.type.t = "bar", window.type.s = "bar",
                       window.size.t = 14, window.size.s = 1/4,
                       make.pval = TRUE, method = "white.noise",
                       n.sim = 100,
                       verbose = FALSE)

wc.image(wc, which.image = "wc",
         n.levels = 250, color.key = "interval",
         siglvl.contour = 0.1, siglvl.arrow = 0.1,
         legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
         main = "Wavelet coherence Germany")

wc.sel.phases(wc, sel.period = 3, siglvl = 1, show.date = TRUE)
  


```


## Exemplarische Auswertung für die einzelnen Regionen

Übersicht über die Verteilung von mittlerer bwz. maximaler PM 2.5 Konzentration und dem Median der täglichen COVID-19 Neuinfektionen bzw. der Summe an Covid-19 Infektionen in NUTS3-Regionen Deutschlands.

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}

pm25 = lapply(nuts3_mean, function(n){
  as.data.frame(n[, "pm25_mean"])[, -2]
})

pm25_dtw_cluster = tsclust(pm25, type = "partitional", k = 3,
                           distance = "dtw_basic", centroid = "pam", seed=11081974, 
                           trace = TRUE,
                           args = tsclust_args(dist = list(window.size = 10)))

plot(pm25_dtw_cluster, type = "c")

new_cases = lapply(nuts3_mean, function(n){
  as.data.frame(n[, "cases"])[, -2]
})

new_cases_dtw_cluster = tsclust(new_cases, type = "partitional", k = 4,
                                distance = "dtw_basic", centroid = "pam", seed=11081974, 
                                trace = TRUE,
                                args = tsclust_args(dist = list(window.size = 10)))

plot(new_cases_dtw_cluster, type = "c")

cluster = lapply(seq(length(nuts3_mean)), function(r){
  data.frame(nuts3 = names(nuts3_mean[r]),
             cluster = pm25_dtw_cluster@cluster[r],
             pm25_mean =  mean(nuts3_mean[[r]]$pm25_mean),
             covid_cases  = max(nuts3_mean[[r]]$cases),
             var = c("mean PM2.5 x mean new covid cases"))
})

cluster = do.call("rbind", cluster)

ggplot(data =cluster, aes(x = pm25_mean, y = covid_cases)) + 
  geom_point() +
  geom_smooth() +
  labs(title = "Overivew PM2.5 x Covid-19 cases", x = "PM 2.5", y = "Covid-19 cases") +
  facet_wrap(~cluster, ncol =3, nrow = 2, scales = "free")
```


```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
overview = lapply(seq(length(nuts3_mean)), function(r){
  data.frame(nuts3 = names(nuts3_mean[r]),
             pm25_mean =  c(mean(nuts3_mean[[r]]$pm25_mean), mean(nuts3_mean[[r]]$pm25_mean),
                            max(nuts3_mean[[r]]$pm25_mean), max(nuts3_mean[[r]]$pm25_mean)),
             covid_cases  = c(median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases),
                              median(nuts3_mean[[r]]$new_cases), max(nuts3_mean[[r]]$cases)),
             var = c("mean PM2.5 x median covid", "mean PM2.5 x sum covid", "max PM2.5 x median covid", "max PM2.5 x sum covid"))
})
overview = do.call(rbind, overview)

ggplot(data =overview, aes(x = pm25_mean, y = covid_cases)) + 
  geom_point() +
  geom_smooth() +
  scale_y_continuous(trans='log2') + 
  labs(title = "Overivew PM2.5 x Covid-19 cases", x = "PM 2.5", y = "Covid-19 cases (log)") +
  facet_wrap(~var, ncol =2, nrow = 2, scales = "free_x")
```

Clusteranalyse über mittlere PM2.5 und den Median der täglichen Covid-Infektionen. Es werden nur Standorte mit einem Median der Infektionen größer oder gleich 2 berücksichtigt. Daten wurden vorher auf jeweils maximalen Wert normiert.
```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
dat = overview[overview$var == "mean PM2.5 x median covid", c("nuts3", "pm25_mean", "covid_cases")]
dat = dat[dat$covid_cases >= 0,]

dat$pm25_mean = dat$pm25_mean/max(dat$pm25_mean)
dat$covid_cases = dat$covid_cases/max(dat$covid_cases)
cls = kmeans(x = dat[, -1], centers = 4)
dat$cluster = as.character(cls$cluster)

ggplot(data = dat, aes(x = pm25_mean, y = covid_cases, colour = cluster)) +
  geom_point() +
  labs(title = "Clusteranalyse PM2.5 x Median der täglichen Covid-19 Infektionen", x = "PM 2.5", y = "Covid-19 cases (norm)", colour = "Cluster-ID")
```


```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
test = nuts3_mean$`SK Köln`
test = nuts3_mean$`SK Krefeld`
test = nuts3_mean$`SK Mönchengladbach`
head(test)

ccf(test$new_cases, test$pm25_mean)


test = nuts3_mean$`SK München`
ccf(test$new_cases, test$pm25_mean)


test = nuts3_mean$`LK Gießen`
ccf(test$new_cases, test$pm25_mean)


model2 <- glm(new_cases ~ pm25_mean, data = test, family = quasipoisson)
model2 <- gam(new_cases ~ pm25_mean, data = test, family = quasipoisson)
summary(model2)

```



## Zeitreihen gruppiert nach Cluster-ID

Die Zahl vor "station average PM2.5" im jeweils ersten Plot eines Orts gibt die Anzahl der PM-Stationen an, deren Zeitreihe für die Analyse gemittelt wurden, um das Messignal zu stabilisieren.

Die Sortierung erfolgt nach Cluster-ID und mittlerem PM2.5 Wert.

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
#Die folgenden Abbildungen zeigen jeweils (i) die Zeitreihen PM 2.5 und neuen COVID-Fälle, (ii) die wavelet coherence, (iii) die Phasendifferenz zwischen den periodischen Komponenten (grün = Differenz nahe 0, Gelb-Grün = PM 2.5 früher als COVID, Türkis = Covid früher als PM 2.5, Blau = inverse Zusammenhang, PM 2.5 vor COVID, Rot = inverser Zusammenhang, Covid vor PM 2.5) und (iv) die Übersicht über wichtige Phasen.


dat = dat[order(dat$cluster, dat$pm25_mean ), ]

coherence = list()
angl = list()

wc_all = list()

for(c in seq(nrow(dat))){
  
  # Plot of PM 2.5 and COVID time series
  # fig = plot_ly()
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~pm25_mean,
  #             name = paste("PM 2.5", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "red"), marker = list(color = "red"))
  # 
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~new_cases,
  #             yaxis = "y2", name = paste("New cases", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "blue"), marker = list(color = "blue"))
  # 
  # fig = fig %>% layout(title= names(it_nuts3_mean[l]),
  #                      yaxis = list(title = "PM 2.5 mean"),
  #                      yaxis2 = list(overlaying = "y", side = "right", title = "new cases"))
  # print(fig)
  print("<P style='page-break-before: always'>")
  
  l = dat[c, "nuts3"]
  
  g = ggplot() +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = pm25_mean, colour  = "PM 2.5 mean")) +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = new_cases/5, colour  = "New cases")) +
    scale_y_continuous(sec.axis = sec_axis(~.*5, name = "New cases")) +
    labs(title = paste(names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"], " | ", substr(nuts3_mean[[l]]$stationname[1], 1, 1), "station average PM2.5 = ", round(mean(nuts3_mean[[l]]$pm25_mean), 2)), x = "Date", y = "PM 25 mean") +
    scale_x_date(date_labels="%d.%m", date_breaks  ="2 day") + 
    theme(axis.text.x = element_text(angle=45)) + 
    scale_colour_manual(name = NULL, values = c("blue", "red"))
  
  print(g)
  
  # Plot of PM 2.5 and COVID wavelet analysis
  wc = analyze.coherency(as.data.frame(nuts3_mean[[l]][, c("date", "pm25_mean", "new_cases")])[, -4],
                         my.pair = c("pm25_mean", "new_cases"),
                         loess.span = 0,
                         dt = 1, dj = 1/20,
                         window.type.t = "bar", window.type.s = "bar",
                         window.size.t = 5, window.size.s = 1/4,
                         make.pval = TRUE, method = "white.noise",
                         n.sim = 100,
                         verbose = FALSE)
  
  
  # wc.image(wc, which.image = "wp",
  #        n.levels = 250,
  #        color.key = "interval",
  #        siglvl.contour = 0.1, siglvl.arrow = 0.1,
  #        legend.params = list(lab = "cross-wavelet power levels"),
  #        show.date = TRUE, main = paste("Cross-wavelet power", names(it_nuts3_mean[l])))
  #
  # wc.avg(wc, which.avg = "wp", exponent = 1,
  #        main = paste("Main frequencies of cross-wavelet power", names(it_nuts3_mean[l])))
  
  wc.image(wc, which.image = "wc",
           n.levels = 250, color.key = "interval",
           siglvl.contour = 0.1, siglvl.arrow = 0.1,
           legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
           main = paste("Wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  # wc.phasediff.image(wc, which.contour = "wc",
  #                    show.date = TRUE,
  #                    main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc.avg(wc, which.avg = "wc", exponent = 1, periodlab = "period (days)",
         main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc_all[c] = wc
  names(wc_all)[c] = names(nuts3_mean[l])
  # wc.sel.phases(wc, sel.period = 4, siglvl = 1, show.date = TRUE)
  
  sel.period = 3.6
  sel.rnum = which(abs(wc$Period - sel.period) == min(abs(wc$Period - sel.period)))
  
  
  # plot(wc$Phase.x[sel.rnum, ], type = "l", col = "red")
  # + lines(wc$Phase.y[sel.rnum, ], col = "blue")
  # + lines(wc$Angle[sel.rnum, ], col = "green")
  
  angl[c] = list(data.frame(phasex = wc$Phase.x[sel.rnum, ],
                            phasey = wc$Phase.y[sel.rnum, ],
                            angle = wc$Angle[sel.rnum, ], 
                            date = wc$series$date,
                            cluster_id = dat[c, "cluster"]))
  names(angl)[c] = names(nuts3_mean[l])
  
  coherence[c] = list(data.frame(coherence_avg = wc$Coherence.avg, 
                                 coherence_avg_pval = wc$Coherence.avg.pval, 
                                 period = wc$Period,
                                 cluster_id = dat[c, "cluster"]))
  names(coherence)[c] = names(nuts3_mean[l])
  
  
}


# saveRDS(wc_all, file.path(envrmt$path_tmp, "wc_all.rds"))
# wc_all = readRDS(file.path(envrmt$path_tmp, "wc_all.rds"))



ang = angl
ang = do.call("rbind", ang)

a = angl
a = a[[which(names(a) == "SK Halle")]] = NULL
a = a[[which(names(a) == "SK Braunschweig")]] = NULL


a = lapply(angl, function(a){
  a$angle
})

dtw_cluster = tsclust(a, type = "partitional", k = 3,
                      distance = "dtw_basic", centroid = "pam", seed=11081974, 
                      trace = TRUE,
                      args = tsclust_args(dist = list(window.size = 10)))

plot(dtw_cluster)

a1 = aggregate(ang$angle, list(ang$date, ang$cluster_id), FUN = mean)
names(a1) = c("date", "cluster_id", "angle")


ggplot(data = ang[which(substr(rownames(ang), 1, 6) == "SK Kre"), ], aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()
ggplot(data = a1, aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()
ggplot(data = a1, aes(x = date, y = angle, color = cluster_id, group = cluster_id)) + geom_path()









coh = coherence

c = lapply(coh, function(c){
  c$coherence_avg
})


c = lapply(coh, function(c){
  tmp = t(c[, c("coherence_avg", "period")])
  colnames(tmp) = tmp[2, ]
  tmp = tmp[1, ]
})




dtw_cluster = tsclust(c, type = "partitional", k = 2,
                      distance = "dtw_basic", centroid = "pam", seed=11081974, 
                      trace = TRUE,
                      args = tsclust_args(dist = list(window.size = 10)))

plot(dtw_cluster, type = "c")









coh[[which(names(coh) == "SK Halle")]] = NULL
coh[[which(names(coh) == "SK Braunschweig")]] = NULL

test = do.call("rbind", coh)

test




t1 = lapply(unique(test$wc.Period), function(u){
  data.frame(cavg = mean(test[test$wc.Period == u, "wc.Coherence.avg"]),
             per = u)
})
t1 = do.call("rbind", t1)

t = aggregate(. ~ period, data = test, FUN = mean)
t1 = aggregate(test$coherence_avg, list(test$period, test$cluster_id), FUN = mean)
names(t1) = c("period", "cluster_id", "coherence_avg")

ggplot(data = t, aes(x = coherence_avg, y = period)) + geom_line()

ggplot(data = t1, aes(x = coherence_avg, y = period, color = cluster_id, group = cluster_id)) + geom_path()

ggplot(data = t1, aes(x = period, y = coherence_avg, color = cluster_id, group = cluster_id)) + geom_line() + geom_smooth(method = "loess", span = 0.3)

plot(t1$coherence_avg, t1$period, type = "l" )



n3_mean = lapply(nuts3_mean, function(n){
  data.frame(n$date, n$pm25_mean, n$new_cases)
})
n3_mean = do.call("rbind", n3_mean)
colnames(n3_mean)

n3_mean_agg = aggregate(. ~ n.date, data = n3_mean, FUN = mean)
colnames(n3_mean_agg) = c("date", "pm25_mean", "new_cases")

ggplot() + 
  geom_line(data = n3_mean_agg, aes(x = date, y = pm25_mean)) + 
  geom_line(data = n3_mean_agg, aes(x = date, y = new_cases))



wc = analyze.coherency(n3_mean_agg,
                       my.pair = c("pm25_mean", "new_cases"),
                       loess.span = 0,
                       dt = 1, dj = 1/8,
                       window.type.t = "bar", window.type.s = "bar",
                       window.size.t = 5, window.size.s = 1/4,
                       make.pval = TRUE, method = "white.noise",
                       n.sim = 100,
                       verbose = FALSE)


wc.image(wc, which.image = "wc",
         n.levels = 250, color.key = "interval",
         siglvl.contour = 0.1, siglvl.arrow = 0.1,
         legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE)


wc.phasediff.image(wc, which.contour = "wc",
                   show.date = TRUE)

wc.sel.phases(wc, sel.period = 4, siglvl = 1, show.date = TRUE)

ccf(n3_mean_agg$new_cases, n3_mean_agg$pm25_mean)



mg_lag =lapply(seq(0,20), function(k){
  mg = gam(n3_mean_agg$new_cases ~ lag(n3_mean_agg$pm25_mean, k), family = quasipoisson())  
})s

for(i in seq(0,20)){
  print(i)
  print(summary(mg_lag[[i+1]])$r.sq)
}

summary(mg_lag[[2]])


# https://rpubs.com/ibn_abdullah/rwcoher
# https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-019-7607-2
# http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf
# https://ehjournal.biomedcentral.com/articles/10.1186/1476-069X-13-102

```

Daten kleiner 2

```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
dat = overview[overview$var == "mean PM2.5 x median covid", c("nuts3", "pm25_mean", "covid_cases")]
dat = dat[dat$covid_cases < 2,]

dat$pm25_mean = dat$pm25_mean/max(dat$pm25_mean)
dat$covid_cases = dat$covid_cases/max(dat$covid_cases)
cls = kmeans(x = dat[, -1], centers = 4)
dat$cluster = as.character(cls$cluster)

ggplot(data = dat, aes(x = pm25_mean, y = covid_cases, colour = cluster)) +
  geom_point() +
  labs(title = "Clusteranalyse PM2.5 x Median der täglichen Covid-19 Infektionen", x = "PM 2.5", y = "Covid-19 cases (norm)", colour = "Cluster-ID")
```


```{r, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results = FALSE}
#Die folgenden Abbildungen zeigen jeweils (i) die Zeitreihen PM 2.5 und neuen COVID-Fälle, (ii) die wavelet coherence, (iii) die Phasendifferenz zwischen den periodischen Komponenten (grün = Differenz nahe 0, Gelb-Grün = PM 2.5 früher als COVID, Türkis = Covid früher als PM 2.5, Blau = inverse Zusammenhang, PM 2.5 vor COVID, Rot = inverser Zusammenhang, Covid vor PM 2.5) und (iv) die Übersicht über wichtige Phasen.


dat = dat[order(dat$cluster, dat$pm25_mean ), ]

for(c in seq(nrow(dat))){
  
  # Plot of PM 2.5 and COVID time series
  # fig = plot_ly()
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~pm25_mean,
  #             name = paste("PM 2.5", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "red"), marker = list(color = "red"))
  # 
  # fig = fig %>%
  #   add_trace(data = it_nuts3_mean[[l]], x = ~date, y = ~new_cases,
  #             yaxis = "y2", name = paste("New cases", names(it_nuts3_mean[l])),
  #             mode = 'lines+markers', line = list(color = "blue"), marker = list(color = "blue"))
  # 
  # fig = fig %>% layout(title= names(it_nuts3_mean[l]),
  #                      yaxis = list(title = "PM 2.5 mean"),
  #                      yaxis2 = list(overlaying = "y", side = "right", title = "new cases"))
  # print(fig)
  print("<P style='page-break-before: always'>")
  l = dat[c, "nuts3"]
  
  g = ggplot() +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = pm25_mean, colour  = "PM 2.5 mean")) +
    geom_line(data = nuts3_mean[[l]], aes(x = date, y = new_cases/5, colour  = "New cases")) +
    scale_y_continuous(sec.axis = sec_axis(~.*5, name = "New cases")) +
    labs(title = paste(names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"], " | ", substr(nuts3_mean[[l]]$stationname[1], 1, 1), "station average PM2.5 = ", round(mean(nuts3_mean[[l]]$pm25_mean), 2)), x = "Date", y = "PM 25 mean") +
    scale_x_date(date_labels="%d.%m", date_breaks  ="2 day") + 
    theme(axis.text.x = element_text(angle=45)) + 
    scale_colour_manual(name = NULL, values = c("blue", "red"))
  
  print(g)
  
  # Plot of PM 2.5 and COVID wavelet analysis
  wc = analyze.coherency(as.data.frame(nuts3_mean[[l]][, c("date", "pm25_mean", "new_cases")])[, -4],
                         my.pair = c("pm25_mean", "new_cases"),
                         loess.span = 0,
                         dt = 1, dj = 1/20,
                         window.type.t = "bar", window.type.s = "bar",
                         window.size.t = 5, window.size.s = 1/4,
                         make.pval = TRUE, method = "white.noise",
                         n.sim = 100,
                         verbose = FALSE)
  
  
  # wc.image(wc, which.image = "wp",
  #        n.levels = 250,
  #        color.key = "interval",
  #        siglvl.contour = 0.1, siglvl.arrow = 0.1,
  #        legend.params = list(lab = "cross-wavelet power levels"),
  #        show.date = TRUE, main = paste("Cross-wavelet power", names(it_nuts3_mean[l])))
  #
  # wc.avg(wc, which.avg = "wp", exponent = 1,
  #        main = paste("Main frequencies of cross-wavelet power", names(it_nuts3_mean[l])))
  
  wc.image(wc, which.image = "wc",
           n.levels = 250, color.key = "interval",
           siglvl.contour = 0.1, siglvl.arrow = 0.1,
           legend.params = list(lab = "cross-wavelet power levels"), show.date = TRUE,
           main = paste("Wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  # wc.phasediff.image(wc, which.contour = "wc",
  #                    show.date = TRUE,
  #                    main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
  wc.avg(wc, which.avg = "wc", exponent = 1, periodlab = "period (days)",
         main = paste("Main frequencies of wavelet coherence", names(nuts3_mean[l]), " | Cluster-ID ", dat[c, "cluster"]))
  
}

# https://rpubs.com/ibn_abdullah/rwcoher
# https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-019-7607-2
# http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf
# https://ehjournal.biomedcentral.com/articles/10.1186/1476-069X-13-102

```



